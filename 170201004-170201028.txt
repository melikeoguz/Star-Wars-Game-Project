///// Graphic /////

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Queue;

import javax.imageio.ImageIO;
import javax.imageio.stream.FileImageInputStream;
import javax.swing.JPanel;
import javax.swing.Timer;

public class Graphic extends JPanel implements KeyListener, ActionListener {

    private BufferedImage heart, reward, darth, luke, master, kylo, stormtrooper, right, left, up, down, win, gameover;
    Timer timer = new Timer(100, this);
    public int grphcDistance;
    public int choosenCharacterX = 306;
    public int choosenCharacterY = 336;
    public int moveX = 40;
    public String[] grphcDoors = new String[20];
    public String choosenCharacter;
    public int[][] grphcMap = new int[11][14];

    int i;
    int alpha = 70;
    Color myColour0 = new Color(255, 20, 147, alpha);
    Color myColour1 = new Color(0, 255, 27, alpha);
    Color myColour2 = new Color(255, 0, 0, alpha);
    Queue<Location> copyQueue = new ArrayDeque<>();
    ArrayList<Character> grphcChr = new ArrayList<Character>();

    /*arraylistin lastindexindeki karakter daima iyi karakter olacaktir. Cunku
     txt okumadan sonra iyi karakter secimi yapiyoruz. Grap[hic kutuphanesi icin
     kullanilacagi zaman bu sira goz onunde tutulmalidir*/
    public Graphic() {
        try {
            heart = ImageIO.read(new FileImageInputStream(new File("heart.png")));
            darth = ImageIO.read(new FileImageInputStream(new File("darth.png")));
            luke = ImageIO.read(new FileImageInputStream(new File("luke.png")));
            master = ImageIO.read(new FileImageInputStream(new File("master.png")));
            reward = ImageIO.read(new FileImageInputStream(new File("reward.png")));
            kylo = ImageIO.read(new FileImageInputStream(new File("kylo.png")));
            stormtrooper = ImageIO.read(new FileImageInputStream(new File("stormtrooper.png")));
            right = ImageIO.read(new FileImageInputStream(new File("right.png")));
            left = ImageIO.read(new FileImageInputStream(new File("left.png")));
            up = ImageIO.read(new FileImageInputStream(new File("up.png")));
            down = ImageIO.read(new FileImageInputStream(new File("down.png")));
            win = ImageIO.read(new FileImageInputStream(new File("win.png")));
            gameover = ImageIO.read(new FileImageInputStream(new File("gameover.png")));
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        setBackground(Color.black);

        timer.start();
    }

    @Override
    public void paint(Graphics g) {

        super.paint(g);

        int i, j, a;
        for (i = 0, a = 0; i < grphcChr.get(grphcChr.size() - 1).getLives(); a = a + 40, i++) {
            g.drawImage(heart, 620 - a, 20, heart.getWidth() / 15, heart.getHeight() / 15, this);
        }

        for (j = 0, a = 0; j < 15; a = a + 40, j++) {
            g.setColor(Color.black);
            g.drawLine(60 + a, 130, 60 + a, 570);
        }

        for (i = 0, a = 0; i < 12; a = a + 40, i++) {
            g.drawLine(60, 130 + a, 620, 130 + a);
        }

        Font font = new Font("Tahoma", Font.CENTER_BASELINE, 12);

        g.setFont(font);
     //   g.setColor(Color.WHITE); /*satir ve sutun degerleri gozukmesi istenirse bu satir aktif edilecek*/
        int locationValues = 0;//matris'i koordinat sistemi gibi kullanacagimiz icin saydirma yaptik
        String sLocationValues; //integer olan locationValues'u stringe cevirip bastirmak icin
        for (i = 0; i < 521; i += 40) {
            sLocationValues = String.valueOf(locationValues); //int degeri ekrana basabilmek icin stringe cevirdik
            g.drawString(sLocationValues, i + 75, 590); //y sabit x artarak ekrana basiliyor(matrisin x-ekseni)
            locationValues++;
        }
        locationValues = 0;
        for (i = 0; i < 401; i += 40) {
            sLocationValues = String.valueOf(locationValues); //int degeri ekrana basabilmek icin stringe cevirdik
            g.drawString(sLocationValues, 45, i + 155); //matrisin y-ekseni
            locationValues++;
        }

        /*Asagidaki kisimda grafikteki duvarlar kodlanmistir*/
        g.setColor(Color.GRAY);
        int y = 0;
        for (i = 0; i < 11; i++) {
            for (j = 0; j < 14; j++) {
                if (grphcMap[i][j] == 0) {
                    g.fillRect(60 + (j * 40), 130 + y, 40, 40);
                }
            }
            y += 40;
        }

        /*Kotu karakterlerin iyi karaktere olan en kisa yolu renklendirildi*/
        for (i = 0; i < grphcChr.size() - 1; i++) {
            for (j = 0; j < grphcChr.get(i).deneme.size(); j++) {

                if (grphcChr.get(i).getName().contains("DarthVader")) {
                    g.setColor(myColour1);
                } else if (grphcChr.get(i).getName().contains("Stormtrooper")) {
                    g.setColor(myColour2);
                } else if (grphcChr.get(i).getName().contains("KyloRen")) {
                    g.setColor(myColour0);
                }
                g.fillRect(60 + (grphcChr.get(i).deneme.get(j).matrixCol) * 40, 130 + (grphcChr.get(i).deneme.get(j).matrixRow) * 40, 40, 40);
            }
        }

        g.setColor(Color.CYAN);
        g.fillRect(220, 130, 40, 40); //Door B
        g.fillRect(540, 130, 40, 40); //Door C
        g.fillRect(60, 330, 40, 40);  //Door A
        g.fillRect(220, 530, 40, 40); //Door E
        g.fillRect(580, 330, 40, 40); //Door D
        g.setColor(Color.yellow);
        g.fillRect(300, 330, 40, 40); //Start point

        g.setColor(Color.black);
        g.drawString("B", 237, 153);
        g.drawString("C", 557, 153);
        g.drawString("A", 77, 353);
        g.drawString("E", 237, 553);
        g.drawString("D", 597, 353);

        /*Asagida grafikte bulunan kapi girisleri ve cikista yer alan odul sembolu kodlanmistir*/
        g.drawImage(reward, 620, 480, reward.getWidth() / 10, reward.getHeight() / 10, this);
        g.drawImage(right, 5, 335, right.getWidth() / 7, right.getHeight() / 7, this);
        g.drawImage(left, 625, 315, left.getWidth() / 7, left.getHeight() / 7, this);
        g.drawImage(up, 225, 570, up.getWidth() / 7, up.getHeight() / 7, this);
        g.drawImage(down, 210, 80, down.getWidth() / 7, down.getHeight() / 7, this);
        g.drawImage(down, 530, 80, down.getWidth() / 7, down.getHeight() / 7, this);

        /*Kullanici tarafindan secilen iyi karakterin turune gore konumu kodlanmistir */
        if (choosenCharacter.equalsIgnoreCase("s")) {
            g.drawImage(luke, choosenCharacterX, choosenCharacterY, luke.getWidth() / 15, luke.getHeight() / 15, this);
        } else if (choosenCharacter.equalsIgnoreCase("m")) {
            g.drawImage(master, choosenCharacterX, choosenCharacterY, master.getWidth() / 15, master.getHeight() / 15, this);
        }

        /*harita.txt den alinan bilgilere gore kotu karakterlerin turune ve sayisine gore konumlari kodlanmistir*/
        for (i = 0; i < grphcChr.size() - 1; i++) {

            if (grphcChr.get(i).getName().contains("DarthVader")) {
                g.drawImage(darth, 65 + (grphcChr.get(i).location.getMatrixCol()) * 40, 135 + (grphcChr.get(i).location.getMatrixRow() * 40), darth.getWidth() / 15, darth.getHeight() / 15, this);
            } else if (grphcChr.get(i).getName().contains("Stormtrooper")) {
                g.drawImage(stormtrooper, 65 + (grphcChr.get(i).location.getMatrixCol()) * 40, 135 + (grphcChr.get(i).location.getMatrixRow() * 40), stormtrooper.getWidth() / 15, stormtrooper.getHeight() / 15, this);
            } else if (grphcChr.get(i).getName().contains("KyloRen")) {
                g.drawImage(kylo, 65 + (grphcChr.get(i).location.getMatrixCol()) * 40, 135 + (grphcChr.get(i).location.getMatrixRow() * 40), kylo.getWidth() / 15, kylo.getHeight() / 15, this);
            }

        }

        /*iyi karakterin cani bittiginde oyunun bittigini ifade eder*/
        if (grphcChr.get(grphcChr.size() - 1).getLives() == 0) {
            g.drawImage(gameover, 0, 65, gameover.getWidth(), gameover.getHeight(), this);
        }
        /*iyi karakter kupayi kazanmissa kullaniciya kazandigina dair bilgi verir*/
        if (choosenCharacterX > 546) {
            g.drawImage(win, 0, 65, win.getWidth(), win.getHeight(), this);
        }

    }

    /*go metodu kotu karakterlerin hareketi icin olusturulmustur*/
    public void go(Queue<Location> copyQueue, ArrayList<Character> grphcChr) {
        int i, m = 0;
        try {
            for (i = 0; i < grphcChr.size() - 1; i++) {
                copyQueue = grphcChr.get(i).shortestPath(grphcMap, grphcChr.get(i).location.getMatrixRow(), grphcChr.get(i).location.getMatrixCol(), grphcChr.get(grphcChr.size() - 1).getLocation().matrixRow, grphcChr.get(grphcChr.size() - 1).getLocation().matrixCol);/*kotu karakter*/
                copyQueue.clear();

                if (grphcChr.get(i).getName().contains("KyloRen")) {
                    
                    if (grphcChr.get(i).deneme.get(i-1).getMatrixCol() == grphcChr.get(grphcChr.size() - 1).location.getxAxis() && grphcChr.get(i).deneme.get(i-1).getMatrixRow() == grphcChr.get(grphcChr.size() - 1).location.getyAxis()) {
                        grphcChr.get(grphcChr.size() - 1).setLives(grphcChr.get(grphcChr.size() - 1).decreaseLives(grphcChr.get(grphcChr.size() - 1).getLives()));
                        System.out.println("\nKALAN CANINIZ: " + grphcChr.get(grphcChr.size() - 1).getLives());
                        choosenCharacterX = 306;
                        choosenCharacterY = 336;
                        grphcChr.get(grphcChr.size() - 1).location.setxAxis(6);
                        grphcChr.get(grphcChr.size() - 1).location.setyAxis(5);
                        grphcChr.get(grphcChr.size() - 1).location.setMatrixCol(6);
                        grphcChr.get(grphcChr.size() - 1).location.setMatrixRow(5);
                        grphcChr.get(grphcChr.size() - 1).setLocation(6, 5);
                        grphcChr.get(grphcChr.size() - 1).setMatrix(5, 6);
                        grphcChr.get(grphcChr.size() - 1).getLocation();

                        for (i = 0; i < grphcChr.size() - 1; i++) {
                            copyQueue = grphcChr.get(i).shortestPath(grphcMap, grphcChr.get(i).location.getMatrixRow(), grphcChr.get(i).location.getMatrixCol(), grphcChr.get(grphcChr.size() - 1).getLocation().matrixRow, grphcChr.get(grphcChr.size() - 1).getLocation().matrixCol);
                            copyQueue.clear();
                        }
                    }
                    grphcChr.get(i).location.setMatrixCol(grphcChr.get(i).deneme.get(m).matrixCol);
                    grphcChr.get(i).location.setMatrixRow(grphcChr.get(i).deneme.get(m).matrixRow);
                 }
                else {
               
                	grphcChr.get(i).location.setMatrixCol(grphcChr.get(i).characterMoveX(grphcChr.get(i).getLocation().matrixCol, grphcChr.get(i).deneme.get(m).matrixCol));
                grphcChr.get(i).location.setMatrixRow(grphcChr.get(i).characterMoveY(grphcChr.get(i).getLocation().matrixRow, grphcChr.get(i).deneme.get(m).matrixRow));
              }
           }

          } catch (IndexOutOfBoundsException e) {
            grphcChr.get(grphcChr.size() - 1).setLives(grphcChr.get(grphcChr.size() - 1).decreaseLives(grphcChr.get(grphcChr.size() - 1).getLives()));
            System.out.println("\nKALAN CANINIZ: " + grphcChr.get(grphcChr.size() - 1).getLives());

            for (i = 0; i < grphcChr.size() - 1; i++) {
                grphcChr.get(i).location.setMatrixCol(grphcChr.get(i).startCol);
                grphcChr.get(i).location.setMatrixRow(grphcChr.get(i).startRow);
                grphcChr.get(i).setLocation(grphcChr.get(i).startCol, grphcChr.get(i).startRow);
                grphcChr.get(i).setMatrix(grphcChr.get(i).startRow, grphcChr.get(i).startCol);
            }
            choosenCharacterX = 306;
            choosenCharacterY = 336;
            grphcChr.get(grphcChr.size() - 1).location.setxAxis(6);
            grphcChr.get(grphcChr.size() - 1).location.setyAxis(5);
            grphcChr.get(grphcChr.size() - 1).location.setMatrixCol(6);
            grphcChr.get(grphcChr.size() - 1).location.setMatrixRow(5);
            grphcChr.get(grphcChr.size() - 1).setLocation(6, 5);
            grphcChr.get(grphcChr.size() - 1).setMatrix(5, 6);
            grphcChr.get(grphcChr.size() - 1).getLocation();

            for (i = 0; i < grphcChr.size() - 1; i++) {
                copyQueue = grphcChr.get(i).shortestPath(grphcMap, grphcChr.get(i).location.getMatrixRow(), grphcChr.get(i).location.getMatrixCol(), grphcChr.get(grphcChr.size() - 1).getLocation().matrixRow, grphcChr.get(grphcChr.size() - 1).getLocation().matrixCol);/*kotu karakter*/
                copyQueue.clear();
            }

        }

    }

    @Override
    public void repaint() {
        super.repaint();
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        repaint();
    }

    @Override
    public void keyPressed(KeyEvent e) {
        /*Bu fonksiyon blogunda her bir tusa basildiginda matrise gore ve kordinat sistemine gore 
        konumlari yeniden set eder. Istenilen harekete gore (sol,sag,yukari,asagi) bulundugu
        konumun bir sonraki halinin matriste 0'a mi, 1'e mi denk geldigine bakar boylece 0 olan
        yerlere ilerleyemez. Unutulmamalidir ki kordinat sistemi duzeni ile matris sistemi duzeni
        birbirinden farkli duzenlendir bu yuzden xAxis ve yAxis kordinat duzlemindeki hareketi temsil
        ederken, matrisRow ve matrisCol matris uzerideki hareketi temsil eder.*/
 /*Sonradan eklenen ozellik; bu blokta her kotu karakter icin iyi karaktere olan en kisa mesafeyi hesaplar.*/

        int key = e.getKeyCode();

        if (key == KeyEvent.VK_LEFT) {

            if (choosenCharacterX <= 60) {
                choosenCharacterX = 60;

            } else {

                if (grphcMap[grphcChr.get(grphcChr.size() - 1).getLocation().matrixRow][grphcChr.get(grphcChr.size() - 1).getLocation().matrixCol - 1] == 0) {/*5,6 sola gidince 5,5 sola gidince 5,4 */
                    System.out.println("grphcChr" + "[" + (grphcChr.get(grphcChr.size() - 1).getLocation().matrixRow) + "] [" + (grphcChr.get(grphcChr.size() - 1).getLocation().matrixCol - 1) + "]");/*bu
                    satir matris uzerinde hangi hucrede olacagini-oldugunu verir*/
                    System.out.println(grphcMap[grphcChr.get(grphcChr.size() - 1).getLocation().matrixRow][grphcChr.get(grphcChr.size() - 1).getLocation().matrixCol - 1]);/*bu satir gidilmek istenen
                    hucrede 0 mi 1 mi oldugunu verir*/
                    choosenCharacterX -= 0;/*gidilecek noktada sifir var ise hareket etmemesini saglar*/
                } else {
                    choosenCharacterX -= moveX;
                    grphcChr.get(grphcChr.size() - 1).setLocation(grphcChr.get(grphcChr.size() - 1).getLocation().xAxis - 1, grphcChr.get(grphcChr.size() - 1).getLocation().yAxis);/*(iyi karakter)kordinat duzlemine gore sola hareket
                    edince x ekseninde azalma olur*/
                    grphcChr.get(grphcChr.size() - 1).setMatrix(grphcChr.get(grphcChr.size() - 1).getLocation().matrixRow, grphcChr.get(grphcChr.size() - 1).getLocation().matrixCol - 1);/*iyi karakter*/

                    go(copyQueue, grphcChr);
                }
            }

        } else if (key == KeyEvent.VK_RIGHT) {
            if (choosenCharacterX >= 580) {
                choosenCharacterX = 580;
            } else {

                if (grphcMap[grphcChr.get(grphcChr.size() - 1).getLocation().matrixRow][grphcChr.get(grphcChr.size() - 1).getLocation().matrixCol + 1] == 0) {
                    System.out.println("grphcChr" + "[" + grphcChr.get(grphcChr.size() - 1).getLocation().matrixRow + "] [" + (grphcChr.get(grphcChr.size() - 1).getLocation().matrixCol + 1) + "]");
                    System.out.println(grphcMap[grphcChr.get(grphcChr.size() - 1).getLocation().matrixRow][grphcChr.get(grphcChr.size() - 1).getLocation().matrixCol + 1]);
                    choosenCharacterX += 0;
                } else {
                    choosenCharacterX += moveX;
                    grphcChr.get(grphcChr.size() - 1).setLocation(grphcChr.get(grphcChr.size() - 1).getLocation().xAxis + 1, grphcChr.get(grphcChr.size() - 1).getLocation().yAxis);
                    grphcChr.get(grphcChr.size() - 1).setMatrix(grphcChr.get(grphcChr.size() - 1).getLocation().matrixRow, grphcChr.get(grphcChr.size() - 1).getLocation().matrixCol + 1);
                    go(copyQueue, grphcChr);
                }

            }
        } else if (key == KeyEvent.VK_UP) {

            if (choosenCharacterY <= 130) {
                choosenCharacterY = 130;
            } else {

                if (grphcMap[grphcChr.get(grphcChr.size() - 1).getLocation().matrixRow - 1][grphcChr.get(grphcChr.size() - 1).getLocation().matrixCol] == 0) {/*5,6 sola gidince 5,5 sola gidince 5,4 */
                    System.out.println("grphcChr" + "[" + (grphcChr.get(grphcChr.size() - 1).getLocation().matrixRow - 1) + "] [" + (grphcChr.get(grphcChr.size() - 1).getLocation().matrixCol) + "]");/*bu
                    satir matris uzerinde hangi hucrede olacagini-oldugunu verir*/
                    System.out.println(grphcMap[grphcChr.get(grphcChr.size() - 1).getLocation().matrixRow - 1][grphcChr.get(grphcChr.size() - 1).getLocation().matrixCol]);/*bu satir gidilmek istenen
                    hucrede 0 mi 1 mi oldugunu verir*/
                    choosenCharacterY -= 0;/*gidilecek noktada sifir var ise hareket etmemesini saglar*/
                } else {
                    choosenCharacterY -= moveX;
                    grphcChr.get(grphcChr.size() - 1).setLocation(grphcChr.get(grphcChr.size() - 1).getLocation().xAxis, grphcChr.get(grphcChr.size() - 1).getLocation().yAxis - 1);
                    grphcChr.get(grphcChr.size() - 1).setMatrix(grphcChr.get(grphcChr.size() - 1).getLocation().matrixRow - 1, grphcChr.get(grphcChr.size() - 1).getLocation().matrixCol);
                    go(copyQueue, grphcChr);

                }

            }
        } else if (key == KeyEvent.VK_DOWN) {
            if (choosenCharacterY >= 540) {
                choosenCharacterY = 540;
            } else {

                if (grphcMap[grphcChr.get(grphcChr.size() - 1).getLocation().matrixRow + 1][grphcChr.get(grphcChr.size() - 1).getLocation().matrixCol] == 0) {/*5,6 sola gidince 5,5 sola gidince 5,4 */
                    System.out.println("grphcChr" + "[" + (grphcChr.get(grphcChr.size() - 1).getLocation().matrixRow + 1) + "] [" + (grphcChr.get(grphcChr.size() - 1).getLocation().matrixCol) + "]");/*bu
                    satir matris uzerinde hangi hucrede olacagini-oldugunu verir*/
                    System.out.println(grphcMap[grphcChr.get(grphcChr.size() - 1).getLocation().matrixRow + 1][grphcChr.get(grphcChr.size() - 1).getLocation().matrixCol]);/*bu satir gidilmek istenen
                    hucrede 0 mi 1 mi oldugunu verir*/
                    choosenCharacterY += 0;/*gidilecek noktada sifir var ise hareket etmemesini saglar*/
                } else {
                    choosenCharacterY += moveX;
                    grphcChr.get(grphcChr.size() - 1).setLocation(grphcChr.get(grphcChr.size() - 1).getLocation().xAxis, grphcChr.get(grphcChr.size() - 1).getLocation().yAxis + 1);
                    grphcChr.get(grphcChr.size() - 1).setMatrix(grphcChr.get(grphcChr.size() - 1).getLocation().matrixRow + 1, grphcChr.get(grphcChr.size() - 1).getLocation().matrixCol);
                    go(copyQueue, grphcChr);
                }
            }
        }

        grphcChr.get(grphcChr.size() - 1).getLocation();
        grphcChr.get(grphcChr.size() - 1).printLocation();

    }

    @Override
    public void keyReleased(KeyEvent e) {
    }

    @Override
    public void keyTyped(KeyEvent e) {
    }

}



///// starWarsProject /////



import java.awt.HeadlessException;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.JFrame;

public class starWarsProject extends JFrame {

    final static int ARow = 5,ACol = 0, BRow = 0,BCol = 4,CRow = 0,CCol = 12,DRow = 5,DCol = 13,ERow = 10,ECol = 4;

    public starWarsProject(String title) throws HeadlessException {
        super(title);

    }

    public static ArrayList<Character> chr = new ArrayList<Character>();

    /*karakterlerin tutulacagi
    arraylist, bu vectorun lastindexindeki karakter daima iyi karakter olacaktir. Cunku
    txt okumadan sonra iyi karakter secimi yapiyoruz. Grap[hic kutuphanesi icin
    kullanilacagi zaman bu sira goz onunde tutulmalidir*/
    public ArrayList<Character> getCharacters() {
        return starWarsProject.chr;
    }

    public static void main(String[] args) throws IOException {
        Scanner input = new Scanner(System.in);
        File harita = new File("harita.txt");
        int row = 0, i, j = 0;
        byte stormtrooperNum = 0, darthVaderNum = 0, kyloRenNum = 0;
        int[][] map = new int[11][14];
        String[] output = null;

        if (!harita.exists()) {
            System.out.println(harita.getName() + " adli dosya bulunamadi.");
            System.exit(0);
        }

        BufferedReader reader = null;
        /*satirlari okumak icin olusturuldu*/
        FileReader forMap = null;

        try {
            reader = new BufferedReader(new FileReader(harita));
            forMap = new FileReader("harita.txt");
        } catch (FileNotFoundException ex) {
            Logger.getLogger(starWarsProject.class.getName()).log(Level.SEVERE, null, ex);
        }

        String line = reader.readLine();/*satiri okumak icin tutulacak degisken */

        while (!(line.startsWith("0") || line.startsWith("1"))) {
            /*bu while blogu 
            icerisinde txtden karakterleri okuma ve uygun nesneleri olusturma
            islemi yapilir*/
           /*harita kodu basladiginda satir basinda 1 veya 0 bulunacagi icin 
            bu yontemi kullandik txt icerisinde basi 0 veya 1 le baslayan satir varsa
            okuma islemi durur*/

            if (line.length() > 0) {
                row++;
                output = line.split("[,:]");/*string parse etme islemleri*/
                System.out.println(output[1]);/*karakter adini verir*/
                System.out.println(output[3]);/*kapi bilgisini verir*/

                if (output[1].equalsIgnoreCase("stormtrooper")) {
                    if (output[3].equalsIgnoreCase("a")) {
                        chr.add(new Stormtrooper("Stormtrooper" + stormtrooperNum, "kotu", ARow, ACol,ARow, ACol));
                        stormtrooperNum++;
                    } else if (output[3].equalsIgnoreCase("b")) {
                        chr.add(new Stormtrooper("Stormtrooper" + stormtrooperNum, "kotu", BRow, BCol, BRow, BCol));
                        stormtrooperNum++;
                    } else if (output[3].equalsIgnoreCase("c")) {
                        chr.add(new Stormtrooper("Stormtrooper" + stormtrooperNum, "kotu", CRow, CCol, CRow, CCol));
                        stormtrooperNum++;
                    } else if (output[3].equalsIgnoreCase("d")) {
                        chr.add(new Stormtrooper("Stormtrooper" + stormtrooperNum, "kotu", DRow, DCol,DRow, DCol));
                        stormtrooperNum++;
                    } else if (output[3].equalsIgnoreCase("e")) {
                        chr.add(new Stormtrooper("Stormtrooper" + stormtrooperNum, "kotu", ERow, ECol,ERow, ECol));
                        stormtrooperNum++;
                    }

                } else if (output[1].equalsIgnoreCase("darth vader")) {
                      darthVaderNum++;
                    if (output[3].equalsIgnoreCase("a")) {
                        chr.add(new DarthVader("DarthVader" + darthVaderNum, "kotu", ARow, ACol, ARow, ACol));
                        darthVaderNum++;
                    } else if (output[3].equalsIgnoreCase("b")) {
                        chr.add(new DarthVader("DarthVader" + darthVaderNum, "kotu", BRow, BCol, BRow, BCol));
                        darthVaderNum++;
                    } else if (output[3].equalsIgnoreCase("c")) {
                        chr.add(new DarthVader("DarthVader" + darthVaderNum, "kotu", CRow, CCol,CRow, CCol));
                        darthVaderNum++;
                    } else if (output[3].equalsIgnoreCase("d")) {
                        chr.add(new DarthVader("DarthVader" + darthVaderNum, "kotu", DRow, DCol,DRow, DCol));
                        darthVaderNum++;
                    } else if (output[3].equalsIgnoreCase("e")) {
                        chr.add(new DarthVader("DarthVader" + darthVaderNum, "kotu", ERow, ECol, ERow, ECol));
                        darthVaderNum++;
                    }

                } else if (output[1].equalsIgnoreCase("kylo ren")) {
                  if (output[3].equalsIgnoreCase("a")) {
                        chr.add(new KyloRen("KyloRen" + kyloRenNum, "kotu", ARow, ACol, ARow, ACol));
                        kyloRenNum++;
                    } else if (output[3].equalsIgnoreCase("b")) {
                        chr.add(new KyloRen("KyloRen" + kyloRenNum, "kotu", BRow, BCol, BRow, BCol));
                        kyloRenNum++;
                    } else if (output[3].equalsIgnoreCase("c")) {
                        chr.add(new KyloRen("KyloRen" + kyloRenNum, "kotu", CRow, CCol, CRow, CCol));
                        kyloRenNum++;
                    } else if (output[3].equalsIgnoreCase("d")) {
                        chr.add(new KyloRen("KyloRen" + kyloRenNum, "kotu", DRow, DCol,DRow, DCol));
                        kyloRenNum++;
                    } else if (output[3].equalsIgnoreCase("e")) {
                        chr.add(new KyloRen("KyloRen" + kyloRenNum, "kotu", ERow, ECol,ERow, ECol));
                        kyloRenNum++;
                    }
                }
            }
            line = reader.readLine();
        }

        try {

            int value, say = 1;
            /*sutun sayilarini hesaplamak icin say degiskeni atandi*/
            i = 0;
            while ((value = forMap.read()) != -1) {
                /*value dosyadan okunan char degeridir.Value,dosyanin sonuna gelince -1 olur*/

                if (value == '0' || value == '1') /*harita bilgisinden onceki verileri kullanmamak icin boyle bir kosul yerlestirdik*/ {
                    //System.out.print((char)value+"\t"); SILINECEK
                    if (value == 48) /*value integer bir deger oldugu icin char okurken onun ascII tablosundaki degerini gosterir*/ {
                        map[i][j] = 0;
                        /*ascII tablosuna gore 0 sayisi 48 e esit gelir ve okunan degeri map dizisine atadik*/
                    } else {
                        map[i][j] = 1;/*ascII tablosuna gore 1 sayisi 49 e esit gelir ve okunan degeri map dizisine atadik*/
                    }

                    say++;
                    /*sutun sayisini arttirdik*/
                    j++;
                    if (say == 15) {
                        say = 1;
                        j = 0;
                        /*map dizisinde sutun degerini gosteren j degiskenini sifirladik*/
                        i++;
                        /*map dizisinde satir sayisinin degerini gosteren i degiskenini arttirdik*/
                    }
                }

            }
        } finally {
            forMap.close();
            /*haritayi okumak icin acilan dosya kapatildi*/
        }

        /*haritanin konum bilgileri ekrana basildi  SILINECEK*/
        for (i = 0; i < 11; i++) {
            for (j = 0; j < 14; j++) {
                System.out.print(map[i][j] + "\t");
            }
            System.out.println();
        }

        System.out.println("KARAKTERLER:\nMaster Yoda karakteri 6 can hakkýna sahiptir.MASTER YODA ICIN M HAFINE BASIN !\nLuke Skywalker karatkeri 3 can hakkýna sahiptir. LUKE SKYWALKER ICIN S HAFINE BASIN !");
        System.out.println("\nKARAKTERINI SEC VE BASLA !\nSECIM:");
        String gamerchr = input.nextLine();

        if (gamerchr.equalsIgnoreCase("m")) {
            chr.add(new MasterYoda("MasterYoda", "Iyi", 6,5,6,5,6));

        } else if (gamerchr.equalsIgnoreCase("s")) {
            chr.add(new LukeSkywalker("LukeSkywalker", "Iyi", 3,5,6,5,6));
        } else {
            while (!(gamerchr.equalsIgnoreCase("m") || gamerchr.equalsIgnoreCase("s"))) {
                System.out.println("Lutfen S ya da M harfi giriniz!");
                gamerchr = input.nextLine();
                if (gamerchr.equalsIgnoreCase("m")) {
                    chr.add(new MasterYoda("MasterYoda", "Iyi", 6,5,6,5,6));
                } else if (gamerchr.equalsIgnoreCase("s")) {
                    chr.add(new LukeSkywalker("LukeSkywalker", "Iyi", 3,5,6,5,6));
                }
            }

        }

        Graphic graphic = new Graphic();
        /*grafik nesnesi olusturuldu*/
        graphic.grphcChr = chr;
        /*graphic classinin icindeki grphcChr arraylistine main iÁindeki arraylist atandi*/
        graphic.grphcMap = map;
        /*Graphic classina harita konum bilgilerini iceren map dizisi gonderildi*/

        starWarsProject screen = new starWarsProject("Star Wars");
        screen.setSize(700, 700);
        screen.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        graphic.requestFocus();
        /*Klavyeden girdi alinacagi icin odagi graphic nesnesine verdik*/
        graphic.addKeyListener(graphic);
        /*Klavyeden gonderilen girdileri alir*/
        graphic.setFocusable(true);
        /*Odak graphic nesnesine verildi*/
        graphic.setFocusTraversalKeysEnabled(false);
        /*Klavye islemlerinnin gerceklesmesi icin yazildi*/

        screen.add(graphic);
        screen.setVisible(true);   /*JFramemin gozukmesi icin girilmis bir komut*/
        screen.setResizable(true); /*Pencere boyutu degistirilebilir nitelikte olmasi icin yazildi*/

        graphic.choosenCharacter = gamerchr;/*kullanicinin sectigi iyi karakter Graphic classina atandi*/
       
        /*kotu karakterlerin en kisa yollarinin boyanmasi icin shortestPath cagrildi*/
        for(i=0;i<chr.size()-1;i++){
        	chr.get(i).shortestPath(map, chr.get(i).location.getMatrixRow(),chr.get(i).location.getMatrixCol(), chr.get(chr.size() - 1).getLocation().matrixRow, chr.get(chr.size() - 1).getLocation().matrixCol);
        }
    }
}





///// Location //////


import java.util.ArrayList;


public class Location {
    
    int xAxis = 0, yAxis = 0, distance = 0;
    int matrixRow = 0, matrixCol = 0;
    
    
    ArrayList<Location> path;
    Location(int matrixRow, int matrixCol, int distance) {
        path=new ArrayList<Location>();
        this.matrixRow = matrixRow;
        this.matrixCol = matrixCol;
        this.distance = distance;
    }

    Location() {
        /*iyi krakterlerin kullanabilmesi icin default constructor*/
    }
    

    public int getxAxis() {
        return xAxis;
    }

    public void setxAxis(int xAxis) {
        this.xAxis = xAxis;
    }

    public int getyAxis() {
        return yAxis;
    }

    public void setyAxis(int yAxis) {
        this.yAxis = yAxis;
    }

    public int getDistance() {
        return distance;
    }

    public void setDistance(int distance) {
        this.distance = distance;
    }

    public int getMatrixRow() {
    	
        return matrixRow;
    }

    public void setMatrixRow(int matrixRow) {
    	this.matrixRow = matrixRow;
    }

    public int getMatrixCol() {
        return matrixCol;
    }

    public void setMatrixCol(int matrixCol) {
    	this.matrixCol = matrixCol;
    }
    

}





///// Character //////

import java.util.Queue;
import java.util.ArrayDeque;
import java.util.ArrayList;

public class Character {

    public String name;/*karakterin adini tutar*/
    public String kind;/*karakterin turunu tutar*/
    Location location = new Location();
    public int lives;
	public int startRow;
	public int startCol;

    public Character(String name, String kind, int matrixRow, int matrixCol, int startRow, int startCol) {
        this.name = name;
        this.kind = kind;
        location.matrixRow = matrixRow;
        location.matrixCol = matrixCol;
        this.startRow=startRow;
        this.startCol=startCol;
    }
    
        public int characterMoveX(int currentX, int nextX){
        if(nextX > currentX){
           return (currentX+1);
        }else if(nextX < currentX){
            return (currentX-1);
        }else{
            return currentX;
        }
    }
    
        public int characterMoveY(int currentY, int nextY){
        if(nextY > currentY){
           return (currentY+1);
        }else if(nextY < currentY){
            return (currentY-1);
        }else{
            return currentY;
        }
    }
        public boolean yakaladiMi(int iyiKRow,int iyiKCol, int kotuKRow, int kotuKCol){
            if(iyiKRow == kotuKRow && iyiKCol == kotuKCol ){
                return true;
            }else{
                return false;
            }
           
        }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getKind() {
        return kind;
    }

    public void setKind(String kind) {
        this.kind = kind;
    }

    public Location getLocation() {
//        System.out.println("Current xAxis :"+location.xAxis);
//        System.out.println("Current yAxis :"+location.yAxis);
        //System.out.println(location.distance);
        return location;
    }

    public void setLocation(int xAxis, int yAxis) {
        this.location.xAxis = xAxis;
        this.location.yAxis = yAxis;
        //this.location = location;
    }

    public void printLocation() {
        System.out.println("xAxis : " + location.xAxis);
        System.out.println("yAxis : " + location.yAxis);
    }

    public void setMatrix(int row, int col) {
        this.location.matrixRow = row;
        this.location.matrixCol = col;
    }

    public void printMatrix() {
        System.out.println("matrix row : " + location.matrixRow);
        System.out.println("matrix col : " + location.matrixCol);

    }

    public int getLives() {
        return lives;
    }

    public void setLives(int lives) {
        this.lives = lives;
    }

    public int decreaseLives(int lives) {/*this method for decreasing live numbers */
        return this.lives=lives-1;
    }

    
    
    // Binary Maze'in boyutu
    private static final int rowNum = 11;
    private static final int colNum = 14;

    // Below arrays details all 4 possible movements from a cell
    // burasi belki gereksizdir degistirilebilir
    private static final int row[] = {-1, 0, 0, 1};
    private static final int col[] = {0, -1, 1, 0};

    // Bu fonksiyon Function to check if it is possible to go to position (row, col)
    // from current position. The function returns false if (row, col)
    // is not a valid position or has value 0 or it is already visited
    private static boolean isValid(int mat[][], boolean visited[][], int row, int col) {
        return (row >= 0) && (row < rowNum) && (col >= 0) && (col < colNum) //O(1)
                && mat[row][col] == 1 && !visited[row][col];
    }

    public int[] arr;

    public ArrayList<Location> kopyala(ArrayList<Location> kopyagel) {
        ArrayList<Location> kopya = new ArrayList<Location>();
        kopya = kopyagel;
        return kopya;
    }

    public ArrayList<Location> deneme = new ArrayList<Location>();

    //shortest path i kopyalamak icin buraya yeni bir q 
    public Queue<Location> q = new ArrayDeque<>();
    public ArrayList<Integer> shortestPathRows;
    public ArrayList<Integer> shortestPathCols;

    
    /* shortestPath methodu belirtilen adresten alinmis olup uzerine eklemeler yapilmistir.
    (https://www.techiedelight.com/lee-algorithm-shortest-path-in-a-maze/).*/
    public Queue<Location> shortestPath(int mat[][], int i, int j, int x, int y) {/*sonrasinda duzenleme yapilacak */

        // construct a matrix to keep track of visited cells
        boolean[][] visited = new boolean[rowNum][colNum];              /// ==== O( 1 ) 1byte

        // create an empty queue
        //Queue<Location> q = new ArrayDeque<>();
        // mark source cell as visited and enqueue the source node
        visited[i][j] = true;                                           /// ===O( 1 ) 1 byte
        q.add(new Location(i, j, 0));                                   /// ===O( 1 ) 24 byte

        // stores length of longest path from source to destination
        int min_dist = Integer.MAX_VALUE;                               ///==== O( 1 ) 4 byte
                
                int complexityCounter = 0;                               // 4 byte
        // run till queue is not empty
        while (!q.isEmpty()) {                                          //====O ( n ) 
            complexityCounter++;
             // pop front node from queue and process it
            Location node = q.poll();                                   // == O ( 1 )

            // (i, j) represents current cell and dist stores its
            // minimum distance from the source
            i = node.matrixRow;                                         // == O ( 1 )
            j = node.matrixCol;                                         // == O ( 1 )
            int dist = node.distance;                                   // == O ( 1 )

            // if destination is found, update min_dist and stop
            if (i == x && j == y) {                                     //=====O(1)
                min_dist = dist;                        
                break;  
            }

            // check for all 4 possible movements from current cell
            // and enqueue each valid movement
            for (int k = 0; k < 4; k++) {                                //=====O(n) complexity m = 5 , 5 * 4 byte 20
                // check if it is possible to go to position
                // (i + row[k], j + col[k]) from current position
                if (isValid(mat, visited, i + row[k], j + col[k])) {     // O ( 1 )
                    // mark next cell as visited and enqueue it
                    visited[i + row[k]][j + col[k]] = true;              //=====O(1)  1 byte
                    q.add(new Location(i + row[k], j + col[k], dist + 1));//====O(1)  24 byte
                }
            }
        }

        if (min_dist != Integer.MAX_VALUE) {
            
            System.out.println("The shortest path from source to destination "
                    + "has length " + min_dist);
                    System.out.println("TIME COMPLEXITY -- O(M*N) = "+(complexityCounter*5));
                    System.out.println("SPACE COMPLEXITY -- O(M*N+46) = "+(complexityCounter*25)+46 + "byte");
        } else {
            System.out.println("Destination can't be reached from source");
            System.out.println("TIME COMPLEXITY -- O(M*N) = "+(complexityCounter*25)+46+"byte");
        }

        
        // big o = O (n*m + 9)
        return q;
    }

}



///// DarthVader //////

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Queue;

public class DarthVader extends Character {

    int darthVaderNumber;

    public DarthVader(String name, String kind, int matrixRow, int matrixCol, int startRow, int startCol) {
        super(name, kind, matrixRow, matrixCol, startRow, startCol);
    }

    @Override
    public int characterMoveX(int currentX, int nextX) {
        return super.characterMoveX(currentX, nextX);
    }

    @Override
    public int characterMoveY(int currentY, int nextY) {
        return super.characterMoveY(currentY, nextY);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = "Darth Vader";
    }

    public String getKind() {
        return kind;
    }

    public void setKind(String kind) {
        this.kind = "Kotu";
    }

    public int getDarthVaderNumber() {
        return darthVaderNumber;
    }

    public void setDarthVaderNumber(int darthVaderNumber) {
        this.darthVaderNumber = darthVaderNumber;
    }
    // Binary Maze'in boyutu
    private static final int rowNum = 11;
    private static final int colNum = 14;

    // Below arrays details all 4 possible movements from a cell
    // burasi belki gereksizdir degistirilebilir
    private static final int row[] = {-1, 0, 0, 1};
    private static final int col[] = {0, -1, 1, 0};

    // Bu fonksiyon Function to check if it is possible to go to position (row, col)
    // from current position. The function returns false if (row, col)
    // is not a valid position or has value 0 or it is already visited
    private static boolean isValid(int mat[][], boolean visited[][], int row, int col) {

        int[][] darthMap = new int[11][14];

        for (int i = 0; i < 11; i++) {
            for (int j = 0; j < 14; j++) {
                darthMap[i][j] = 1;
            }
        }
        mat = darthMap;

        return (row >= 0) && (row < rowNum) && (col >= 0) && (col < colNum)
                && mat[row][col] == 1 && !visited[row][col];
    }

    public Queue<Location> q = new ArrayDeque<>();
    public int[] arr;

    @Override
    public ArrayList<Location> kopyala(ArrayList<Location> kopyagel) {
        return super.kopyala(kopyagel);
    }

    @Override
    public Queue<Location> shortestPath(int mat[][], int i, int j, int x, int y) {

        // construct a matrix to keep track of visited cells
        boolean[][] visited = new boolean[rowNum][colNum];

        // create an empty queue
        // mark source cell as visited and enqueue the source node
        visited[i][j] = true;
        //Location ccc;

        q.add(new Location(i, j, 0));

        // stores length of longest path from source to destination
        int min_dist = Integer.MAX_VALUE;
        int complexityCounter = 0;
        // run till queue is not empty
        while (!q.isEmpty()) {
            complexityCounter++;
            // pop front node from queue and process it
            Location node = q.poll();
            // (i, j) represents current cell and dist stores its
            // minimum distance from the source
            i = node.matrixRow;
            j = node.matrixCol;

            int dist = node.distance;

            // if destination is found, update min_dist and stop
            if (i == x && j == y) {
                min_dist = dist;

                for (int it = 0; it < node.path.size(); it++) {

                    System.out.println("------" + node.path.get(it).getMatrixRow() + "  " + node.path.get(it).getMatrixCol());
                }
                deneme = kopyala(node.path);
                break;

            }

            // check for all 4 possible movements from current cell
            // and enqueue each valid movement
            for (int k = 0; k < 4; k++) {
                // check if it is possible to go to position
                // (i + row[k], j + col[k]) from current position
                if (isValid(mat, visited, i + row[k], j + col[k])) {
                    // mark next cell as visited and enqueue it
                    visited[i + row[k]][j + col[k]] = true;
                    Location tt = new Location(i + row[k], j + col[k], dist + 1);
                    tt.path = (ArrayList<Location>) node.path.clone();
                    tt.path.add(tt);

                    q.add(tt);
                }
            }
        }

        if (min_dist != Integer.MAX_VALUE) {

            System.out.println("The shortest path from source to destination "
                    + "has length " + min_dist);
            System.out.println("\ndart vaderdayiz");
            System.out.println("TIME COMPLEXITY -- O(M*N) = " + (complexityCounter * 5));
            System.out.println("SPACE COMPLEXITY -- O(M*N+46) = "+(complexityCounter*25)+46+"byte");
        } else {
            System.out.println("Destination can't be reached from source");
            System.out.println("TIME COMPLEXITY -- O(M*N) = " + (complexityCounter * 5));
            System.out.println("SPACE COMPLEXITY -- O(M*N+46) = "+(complexityCounter*25)+46+"byte");
        }

        return q;
    }

    public Character addDarthVader(Character darthVader) {
        darthVader.setName("Darth Vader" + darthVaderNumber);
        darthVader.setKind("Kotu");
        return darthVader;
    }

    public void incrementDarthVaderNumber() {
        this.darthVaderNumber++;
    }

}




///// Stormtrooper //////


import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Queue;

public class Stormtrooper extends Character {

    int stormtrooperNumber;

    public Stormtrooper(String name, String kind, int matrixRow, int matrixCol, int startRow, int startCol) {
        super(name, kind, matrixRow, matrixCol, startRow, startCol);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        name = "Stromtrooper";
    }

    public String getKind() {
        return kind;
    }

    public void setKind(String kind) {
        kind = "Kotu";
    }

    public int getStormtrooperNumber() {
        return stormtrooperNumber;
    }

    public void setStormtrooperNumber(int stormtrooperNumber) {
        this.stormtrooperNumber = stormtrooperNumber;
    }

    @Override
    public int characterMoveX(int currentX, int nextX) {
        return super.characterMoveX(currentX, nextX);
    }

    @Override
    public int characterMoveY(int currentY, int nextY) {
        return super.characterMoveY(currentY, nextY);
    }
    // Binary Maze'in boyutu
    private static final int rowNum = 11;
    private static final int colNum = 14;

    // Below arrays details all 4 possible movements from a cell
    // burasi belki gereksizdir degistirilebilir
    private static final int row[] = {-1, 0, 0, 1};
    private static final int col[] = {0, -1, 1, 0};

    // Bu fonksiyon Function to check if it is possible to go to position (row, col)
    // from current position. The function returns false if (row, col)
    // is not a valid position or has value 0 or it is already visited
    private static boolean isValid(int mat[][], boolean visited[][], int row, int col) {
        return (row >= 0) && (row < rowNum) && (col >= 0) && (col < colNum)
                && mat[row][col] == 1 && !visited[row][col];
    }

    public Queue<Location> q = new ArrayDeque<>();

    @Override
    public ArrayList<Location> kopyala(ArrayList<Location> kopyagel) {
        return super.kopyala(kopyagel);
    }

    /* shortestPath methodu belirtilen adresten alinmis olup uzerine eklemeler yapilmistir.
    (https://www.techiedelight.com/lee-algorithm-shortest-path-in-a-maze/).*/
    @Override
    public Queue<Location> shortestPath(int mat[][], int i, int j, int x, int y) {
        /*sonrasinda duzenleme yapilacak */

        // construct a matrix to keep track of visited cells
        boolean[][] visited = new boolean[rowNum][colNum];

        // create an empty queue
        //Queue<Location> q = new ArrayDeque<>();
        // mark source cell as visited and enqueue the source node
        visited[i][j] = true;
        q.add(new Location(i, j, 0));

        // stores length of longest path from source to destination
        int min_dist = Integer.MAX_VALUE;
            int complexityCounter = 0;
        // run till queue is not empty
        while (!q.isEmpty()) {
            complexityCounter++;
            // pop front node from queue and process it
            Location node = q.poll();

            // (i, j) represents current cell and dist stores its
            // minimum distance from the source
            i = node.matrixRow;
            j = node.matrixCol;
            int dist = node.distance;

            // if destination is found, update min_dist and stop
            if (i == x && j == y) {
                min_dist = dist;

                for (int it = 0; it < node.path.size(); it++) {
                    //ekleme
                    System.out.println("------" + node.path.get(it).getMatrixRow() + "  " + node.path.get(it).getMatrixCol());
                }
                //ekleme
                deneme = kopyala(node.path);
                break;
            }

            // check for all 4 possible movements from current cell
            // and enqueue each valid movement
            for (int k = 0; k < 4; k++) {
                // check if it is possible to go to position
                // (i + row[k], j + col[k]) from current position
                if (isValid(mat, visited, i + row[k], j + col[k])) {
                    // mark next cell as visited and enqueue it
                    visited[i + row[k]][j + col[k]] = true;

                    Location tt = new Location(i + row[k], j + col[k], dist + 1);
                    //ekleme
                    tt.path = (ArrayList<Location>) node.path.clone();
                    tt.path.add(tt);

                    q.add(tt);
                }
            }
        }

        if (min_dist != Integer.MAX_VALUE) {
            
            System.out.println("The shortest path from source to destination "
                    + "has length " + min_dist);
                    System.out.println("TIME COMPLEXITY -- O(M*N) = "+(complexityCounter*5));
                    System.out.println("SPACE COMPLEXITY -- O(M*N+46) = "+(complexityCounter*25)+46+"byte");
        } else {
            System.out.println("Destination can't be reached from source");
            System.out.println("TIME COMPLEXITY -- O(M*N) = "+(complexityCounter*5));
            System.out.println("SPACE COMPLEXITY -- O(M*N+46) = "+(complexityCounter*25)+46+"byte");
        }
        System.out.println("\nstormtrooperdayiz");
        
        //ekleme
        return q;
    }

    public Character addStormtrooper(Character Stormtrooper) {
        Stormtrooper.setName("Stormtrooper" + stormtrooperNumber);
        Stormtrooper.setKind("Kotu");
        //Stormtrooper.setLocation(location); // duzelt ;   location i nasil olusturacagimiz belli degil su an     

        return Stormtrooper;
    }

    public void incrementStormtrooperNumber() {
        this.stormtrooperNumber++;
    }
}





///// KyloRen //////

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Queue;

public class KyloRen extends Character {

    int kyloRenNumber;

    public KyloRen(String name, String kind,int matrixRow, int matrixCol,int startRow,int startCol) {
        super(name, kind, matrixRow, matrixCol,startRow,startCol);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = "Kylo Ren";
    }

    public String getKind() {
        return kind;
    }

    public void setKind(String kind) {
        this.kind = "Kotu";
    }

    public int getKyloRenNumber() {
        return kyloRenNumber;
    }

    public void setKyloRenNumber(int kyloRenNumber) {
        this.kyloRenNumber = kyloRenNumber;
    }
    
    @Override
	public int characterMoveX(int currentX, int nextX) {
		return super.characterMoveX(currentX, nextX);
	}

	@Override
	public int characterMoveY(int currentY, int nextY) {
		return super.characterMoveY(currentY, nextY);
	}
	
    public ArrayList<Location> kyloArrayMove(ArrayList<Location> nodePath) {
        /*pathi aldik */

        /*Bu method shortestPath icerisindeki path i kyloRen in ikiser ikiser  
        giderek graphic classina kopyalarken degiserek kopyalanmasi icin yazilmistir.*/
        
        ArrayList<Location> kyloarrayMove = new ArrayList<Location>();

        if (nodePath.size() % 2 == 0) {/*size cift sayi ise cifleri indisleri sil*/
            for (int i = 0; i < nodePath.size(); i++) {
                if (i % 2 == 1) /*i tek sayiysa kopyala */ {
                    kyloarrayMove.add(nodePath.get(i));
                 }

            }
        } else if(nodePath.size() % 2 == 1){//size tek sayiysa
            for (int i = 0; i < nodePath.size(); i++) {
                if (i % 2 == 1 || i == nodePath.size()-1) /*i tek sayiysa kopyala */ {
                    kyloarrayMove.add(nodePath.get(i));
                }
            }

        }

        return kyloarrayMove;/*path olarak doner*/
    }

	
    // Binary Maze'in boyutu
    private static final int rowNum = 11;
    private static final int colNum = 14;

    // Below arrays details all 4 possible movements from a cell
    private static final int row[] = {-1, 0, 0, 1};
    private static final int col[] = {0, -1, 1, 0};

    // Bu fonksiyon Function to check if it is possible to go to position (row, col)
    // from current position. The function returns false if (row, col)
    // is not a valid position or has value 0 or it is already visited
    private static boolean isValid(int mat[][], boolean visited[][], int row, int col) {
        return (row >= 0) && (row < rowNum) && (col >= 0) && (col < colNum)
                && mat[row][col] == 1 && !visited[row][col];
    }
    // create an empty queue
    public Queue<Location> q = new ArrayDeque<>();



    @Override
	public ArrayList<Location> kopyala(ArrayList<Location> kopyagel) {/*Bu method shortestPath icerisindeki
            path i graphic  classinda kullanabilmek icin yazilmistir.*/
		return super.kopyala(kopyagel);
	}

    /* shortestPath methodu belirtilen adresten alinmis olup uzerine eklemeler yapilmistir.
    (https://www.techiedelight.com/lee-algorithm-shortest-path-in-a-maze/).*/
    @Override
    public Queue<Location> shortestPath(int mat[][], int i, int j, int x, int y) {
        /*void olan bu fonksiyonu queueleri dondurecek sekilde yaptik gelen dogru 
        queue yi alip icerisinden dogru konumlari aliyoruz (grafikte) */
        
        
        // construct a matrix to keep track of visited cells
        boolean[][] visited = new boolean[rowNum][colNum];

        // mark source cell as visited and enqueue the source node
        visited[i][j] = true;
        q.add(new Location(i, j, 0));

        // stores length of longest path from source to destination
        int min_dist = Integer.MAX_VALUE;
        int complexityCounter=0;
        // run till queue is not empty
        while (!q.isEmpty()) {
            complexityCounter++;
            // pop front node from queue and process it
            Location node = q.poll();

            // (i, j) represents current cell and dist stores its
            // minimum distance from the source
            i = node.matrixRow;
            j = node.matrixCol;
            int dist = node.distance;

            // if destination is found, update min_dist and stop
            if (i == x && j == y) {
                min_dist = dist;
                for (int it = 0; it < node.path.size(); it++) {

                	System.out.println("------" + node.path.get(it).getMatrixRow() + "  " + node.path.get(it).getMatrixCol());
                }
                deneme = kopyala(kyloArrayMove(node.path));
                break;
            }

            // check for all 4 possible movements from current cell
            // and enqueue each valid movement
            for (int k = 0; k < 4; k++) {
                // check if it is possible to go to position
                // (i + row[k], j + col[k]) from current position
                if (isValid(mat, visited, i + row[k], j + col[k])) {
                    // mark next cell as visited and enqueue it
                    visited[i + row[k]][j + col[k]] = true;

                    Location tt = new Location(i + row[k], j + col[k], dist + 1);
                    tt.path = (ArrayList<Location>) node.path.clone();
                    tt.path.add(tt);

                    q.add(tt);
                }
            }
        }

        if (min_dist != Integer.MAX_VALUE) {
            System.out.println("The shortest path from source to destination "
                    + "has length " + min_dist);
            System.out.println("\nkylorendeyiz");
            System.out.println("TIME COMPLEXITY -- O(M*N) = " + (complexityCounter * 5));
            System.out.println("SPACE COMPLEXITY -- O(M*N+46) = "+(complexityCounter*25)+46+"byte");
        } else {
            System.out.println("Destination can't be reached from source");
            System.out.println("\nkylorendeyiz");
            System.out.println("TIME COMPLEXITY -- O(M*N) = " + (complexityCounter * 5));
            System.out.println("SPACE COMPLEXITY -- O(M*N+46) = "+(complexityCounter*25)+46+"byte");
        }

        return q;
    }



	public Character addKyloRen(Character kyloRen) {
        kyloRen.setName("Kylo Ren" + kyloRenNumber);
        kyloRen.setKind("Kotu");
        //kyloRen.setLocation(location); // duzelt ;   location i nasil olusturacagimiz belli degil su an     

        return kyloRen;
    }

    public void incrementkyloRenNumber() {
        this.kyloRenNumber++;
    }

}




///// LukeSkywalker //////
public class LukeSkywalker extends Character {

    public int lives;
    private Location location = new Location();

    public LukeSkywalker(String name, String kind,int lives,int matrixRow, int matrixCol, int startRow, int startCol) {
        super(name, kind, matrixRow, matrixCol, startRow, startCol);
        this.location.matrixRow = 5; // map [satir] [sutun]
        this.location.matrixCol = 6;
        this.location.xAxis = 6; //kordinat duzlemi sistemi
        this.location.yAxis = 5;
        this.lives=lives;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        name = "Luke Skywalker";
    }

    public String getKind() {
        return kind;
    }

    public void setKind(String kind) {
        kind = "Iyi";
    }

    public Location getLocation() {
        return location;
    }

    public void setLocation(int xAxis, int yAxis) {
        this.location.xAxis = xAxis;
        this.location.yAxis = yAxis;
    }

    public void printLocation() {
        System.out.println("xAxis : " + location.xAxis);
        System.out.println("yAxis : " + location.yAxis);
    }

    public void setMatrix(int row, int col) {
        this.location.matrixRow = row;
        this.location.matrixCol = col;
    }

    public void printMatrix() {
        System.out.println("matrix row : " + location.matrixRow);
        System.out.println("matrix col : " + location.matrixCol);

    }

    public int getLives() {
        return lives;
    }

    public void setLives(int lives) {
        this.lives = lives;
    }

    public int decreaseLives(int lives) {/*this method for decreasing live numbers */
        return this.lives=lives-1;
    }
}




///// MasterYoda //////
public class MasterYoda extends Character {

    private Location location = new Location();

    public MasterYoda(String name, String kind,int lives,int matrixRow, int matrixCol,int startRow,int startCol) {
        super(name, kind, matrixRow, matrixCol,startRow,startCol);
        this.location.matrixRow = 5; // map [satir] [sutun]
        this.location.matrixCol = 6;
        this.location.xAxis = 6;
        this.location.yAxis = 5;
        this.lives=lives;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        name = "Master Yoda";
    }

    public String getKind() {
        return kind;
    }

    public void setKind(String kind) {
        kind = "Iyi";
    }

    public Location getLocation() {
        return location;
    }

    public void setLocation(int xAxis, int yAxis) {
        this.location.xAxis = xAxis;
        this.location.yAxis = yAxis;
    }

    public void printLocation() {
        System.out.println("xAxis : " + location.xAxis);
        System.out.println("yAxis : " + location.yAxis);
    }

    public void setMatrix(int row, int col) {
        this.location.matrixRow = row;
        this.location.matrixCol = col;
    }

    public void printMatrix() {
        System.out.println("matrix row : " + location.matrixRow);
        System.out.println("matrix col : " + location.matrixCol);

    }

    public int getLives() {
        return lives;
    }

    public void setLives(int lives) {
        this.lives = lives;
    }

    public int decreaseLives(int lives) {/*this method for decreasing live numbers */
    	return this.lives=lives-1;
    }

}

